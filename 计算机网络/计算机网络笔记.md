# 计算机网络笔记

## 五层参考模型

⽹络协议通常是由上到下，分成 5 层没，分别是应⽤层，传输层，⽹络层，数据链路层和物理层。

### 传输层协议

TCP 的全称叫传输层控制协议（Transmission Control Protocol），⼤部分应⽤使⽤的正是 TCP 传输层协议，⽐ 如 HTTP 应⽤层协议。TCP 相⽐ UDP 多了很多特性，⽐如流量控制、超时重传、拥塞控制等，这些都是为了保证数据包能可靠地传输给对⽅。

 UDP 就相对很简单，简单到只负责发送数据包，不保证数据包是否能抵达对⽅，但它实时性相对更好，传输效率也⾼。当然，UDP 也可以实现可靠传输，把 TCP 的特性在应⽤层上实现。

### 网络层协议

⽹络层最常使⽤的是 IP 协议（Internet Protocol），IP 协议会将传输层的报⽂作为数据部分，再加上 IP 包头组装 成 IP 报⽂，如果 IP 报⽂⼤⼩超过 MTU（以太⽹中⼀般为 1500 字节）就会再次进⾏分⽚，得到⼀个即将发送到⽹ 络的IP 报⽂。

![image-20220409223223860](D:\project\笔记\计算机网络\pic\image-20220409223223860.png)

为了识别不同的设备，⽹络层需要有区分设备的编号。 我们⼀般⽤ IP 地址给设备进⾏编号，对于 IPv4 协议， IP 地址共 32 位，分成了四段，每段是 8 位。

IP 地址可分为两部分： 

- ⽹络号，负责标识该 IP 地址是属于哪个⼦⽹的 
- 主机号，负责标识同⼀⼦⽹下的不同主机

### 数据链路层

为⽹络层提供链路级别传输的服务。

每⼀台设备的⽹卡都会有⼀个 MAC 地址，它就是⽤来唯⼀标识设备的。路由器计算出了下⼀个⽬的地 IP 地址，再通过 ARP 协议找到该⽬的地的 MAC 地址，这样就知道这个 IP 地址是哪个设备的了。

### 物理层 

当数据准备要从设备发送到⽹络时，需要把数据包转换成电信号，让其可以在物理介质中传输，这⼀层就是物理层 （Physical Layer），物理层主要定义了网络中的电气特性。

## HTTP

HTTP 是超⽂本传输协议，也就是HyperText Transfer Protocol。

### 状态码

![image-20220409224307494](D:\project\笔记\计算机网络\pic\http状态码.png)

```
301 永久重定向， 302临时重定向 304 Not Modified 

400 Bad Request 笼统来说请求报文有误 
403 forbidden 服务器禁止访问 
404 not found 找不到资源

500 Internal Server Error 笼统表示服务器内部处理错误 
501 Not implemented 功能尚不支持 
502 Bad GateWay 服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，后端服务器错误 
503 Service Unavaliable 服务器忙
```

### 常见字段

```
Host 指定服务器域名

Content-Length 字段 ：服务器在返回数据时，会有 Content-Length 字段，表明本次回应的数据⻓度。

Connection 字段最常⽤于客户端要求服务器使⽤ TCP 持久连接，以便其他请求复⽤。HTTP/1.1 版本的默认连接都是持久连接，但为了兼容⽼版本的 HTTP，需要指定 Connection ⾸部字段的值为 Keep-Alive。

Content-Type ：字段⽤于服务器回应时，告诉客户端，本次数据是什么格式。

Content-Encoding ：字段说明数据的压缩⽅法。表示服务器返回的数据使⽤了什么压缩格式。
```

### GET 与 POST

Get ⽅法的含义是请求从服务器获取资源，这个资源可以是静态的⽂本、⻚⾯、图⽚视频等。

POST ⽅法则向 URI 指定的资源提交数据，数据就放在报⽂的 body ⾥。

### 优点

「简单、灵活和易于扩展、应⽤⼴泛和跨平台」。

1. 简单 

   HTTP 基本的报⽂格式就是 header + body ，头部信息也是 key-value 简单⽂本的形式，易于理解，降低了学 习和使⽤的⻔槛。

2. 灵活和易于扩展

   HTTP协议⾥的各类请求⽅法、URI/URL、状态码、头字段等每个组成要求都没有被固定死，都允许开发⼈员⾃定义和扩充。 同时 HTTP 由于是⼯作在应⽤层（ OSI 第七层），则它下层可以随意变化。 HTTPS 也就是在 HTTP 与 TCP 层之间增加了 SSL/TLS 安全传输层，HTTP/3 甚⾄把 TCP 层换成了基于 UDP 的 QUIC。

### 缺点

1. 无状态

   ⽆状态的好处，因为服务器不会去记忆 HTTP 的状态，能减轻服务器的负担，把更多的 CPU 和内存⽤来提供服务。⽆状态的坏处，既然服务器没有记忆能⼒，它在完成有关联性的操作时会⾮常麻烦。

2. 明文传输

3. 不安全

   - 通信使⽤明⽂（不加密），内容可能会被窃听。
   - 不验证通信⽅的身份，因此有可能遭遇伪装。
   - ⽆法证明报⽂的完整性，所以有可能已遭篡改。

### 改进

#### HTTP/1.1    HTTP/2     HTTP/3

![image-20220418121004397](D:\project\笔记\计算机网络\pic\HTTP123.png)

##### HTTP1.1

###### 改进

-  使⽤ TCP ⻓连接的⽅式改善了 HTTP/1.0 短连接造成的性能开销。 
- ⽀持管道（pipeline）⽹络传输，只要第⼀个请求发出去了，不必等其回来，就可以发第⼆个请求出去，可以 减少整体的响应时间。

###### 不足

- 请求 / 响应头部（Header）未经压缩就发送，⾸部信息越多延迟越⼤，只能压缩 Body 的部分； 
- 发送冗⻓的⾸部，每次互相发送相同的⾸部造成的浪费较多； 
- 服务器是按请求的顺序响应的，如果服务器响应慢，会招致客户端⼀直请求不到数据，也就是队头阻塞；
-  没有请求优先级控制； 
- 请求只能从客户端开始，服务器只能被动响应。

##### HTTP2

###### 改进

1. 头部压缩

   HTTP/2 会压缩头（Header）如果你同时发出多个请求，他们的头是⼀样的或是相似的，那么，协议会帮你消除重 复的部分。 这就是所谓的 HPACK 算法：在客户端和服务器同时维护⼀张头信息表，所有字段都会存⼊这个表，⽣成⼀个索引 号，以后就不发送同样字段了，只发送索引号，这样就提⾼速度了。

2. ⼆进制格式

   HTTP/2 不再像 HTTP/1.1 ⾥的纯⽂本形式的报⽂，⽽是全⾯采⽤了⼆进制格式，头信息和数据体都是⼆进制，并 且统称为帧（frame）：头信息帧和数据帧，增加了数据传输的效率。

3. 数据流

   HTTP/2 的数据包不是按顺序发送的，同⼀个连接⾥⾯连续的数据包，可能属于不同的回应。因此，必须要对数据包做标记，指出它属于哪个回应。 每个请求或回应的所有数据包，称为⼀个数据流（ Stream ）。每个数据流都标记着⼀个独⼀⽆⼆的编号，其中规定客户端发出的数据流编号为奇数，服务器发出的数据流编号为偶数客户端还可以指定数据流的优先级。优先级⾼的请求，服务器就先响应该请求。

4. 多路复用

   HTTP/2 是可以在⼀个连接中并发多个请求或回应，⽽不⽤按照顺序⼀⼀对应。 移除了 HTTP/1.1 中的串⾏请求，不需要排队等待，也就不会再出现「队头阻塞」问题，降低了延迟，⼤幅度提⾼ 了连接的利⽤率。 

5. 服务器推送

   HTTP/2 还在⼀定程度上改善了传统的「请求 - 应答」⼯作模式，服务不再是被动地响应，也可以主动向客户端发 送消息。 举例来说，在浏览器刚请求 HTML 的时候，就提前把可能会⽤到的 JS、CSS ⽂件等静态资源主动发给客户端，减少延时的等待，也就是服务器推送（Server Push，也叫 Cache Push）。

###### 不足

​	多个 HTTP 请求在复⽤⼀个 TCP 连接，下层的 TCP 协议是不知道有多少个 HTTP 请求 的。所以⼀旦发⽣了丢包现象，就会触发 TCP 的重传机制，这样在⼀个 TCP 连接中的所有的 HTTP 请求都必须等 待这个丢了的包被重传回来。

##### HTTP3

###### 改进

将传输层协议改为UDP，使用QUIC（Quick UDP Internet Connection）协议保证传输的可靠性的。

- 当某个流发⽣丢包时，只会阻塞这个流，其他流不会受到影响。 

- TLS3 升级成了最新的 1.3 版本，头部压缩算法也升级成了 QPack 。

- HTTPS 要建⽴⼀个连接，要花费 6 次交互，先是建⽴三次握⼿，然后是 TLS/1.3 的三次握⼿。QUIC 直接把 以往的 TCP 和 TLS/1.3 的 6 次交互合并成了 3 次，减少了交互次数。



#### HTTPS 

- HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP ⽹络层之间加⼊了 SSL/TLS（Secure Sockets Layer/Transport Layer Security） 安全协议，使得报⽂能够加密传输。
- HTTP 连接建⽴相对简单， TCP 三次握⼿之后便可进⾏ HTTP 的报⽂传输。⽽ HTTPS 在 TCP 三次握⼿之 后，还需进⾏ SSL/TLS 的握⼿过程，才可进⼊加密报⽂传输。
- HTTP 的端⼝号是 80，HTTPS 的端⼝号是 443。
-  HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。



HTTPS解决了HTTP协议的 

1. 窃听风险，加密算法
2. 篡改风险，通过 摘要算法
3. 冒充风险，通过 数字证书

**摘要算法**

摘要算法⽤来实现完整性，能够为数据⽣成独⼀⽆⼆的「指纹」，⽤于校验数据的完整性，解决了篡改的⻛险。

**数字证书**

通过第三方权威机构保证服务器公钥的可信度。

![image-20220418110849612](D:\project\笔记\计算机网络\pic\ca数字证书.png)

HTTPS 是如何建⽴连接的？其间交互了什么？

SSL/TLS 协议基本流程： （这之前要先建立TCP连接）混合加密方式

- 客户端向服务器索要并验证服务器的公钥。 
- 双⽅协商⽣产「会话秘钥」。 
- 双⽅采⽤「会话秘钥」进⾏加密通信。

![img](D:\project\笔记\计算机网络\pic\SSL握手流程图.png)

四次握手 第一次RTT约定加密方式， 第二次RTT验证加密效果。

##### D-H算法

RSA算法的缺点

RSA 没有向前安全性，也就是需要每次的对称加密密钥的传递都是基于公钥加密，服务端私钥解密。如果服务端的私钥丢失了，那几年前的通信数据都有可能被解密。

![image-20220418205749314](D:\project\笔记\计算机网络\pic\D-H算法.png)

DH算法中，私钥是随机数，公钥根据随机数生成，所以可以不断更换，满足前向安全。

```java
	双方的任何一方可以生成公共参数p和g，这两个数是公开的，被截获了也没有任何关系，一般情况下由通信双方的服务器端计算。p是一个很大的质数，建议长度在1024比特以上，这个长度也决定了DH算法的安全程度，g表示为一个生成器，这个值很小，可以是2或者5。通过参数，服务器端和客户端会生各自生成一个DH密钥对，私钥需要保密。
	客户端根据公开参数生成一个随机数a，这个随机数是私钥，只有客户端知道，且不会进行发送，然后计算A = (g ^ a) mod p, A就是公钥，需要发送给服务器端。
	服务器端根据公开参数生成一个随机数b，这个随机数是私钥，需要服务器端保密，然后计算B = (g ^ b) mod p, B是公钥，需要发送给客户端。
	客户端发送A数值给服务器端，服务器端计算K = (A ^ b) mod p。
	服务器端发送B数值给发送方，客户端计算K = (B ^ a) mod p。
	服务器端和客户端生成的Z就是会话密钥，协商完成。
```

##### ECDHE握手解析

DHE 算法

​	双⽅的私钥在每次密钥交换通信时，都是随机⽣成的、临时 的，这个⽅式也就是 DHE 算法，E 全称是 ephemeral（临时性的）。 所以，即使有个⽜逼的⿊客破解了某⼀次通信过程的私钥，其他通信过程的私钥仍然是安全的，因为每个通信过程 的私钥都是没有任何关系的，都是独⽴的，这样就保证了「前向安全」。

ECDHE 算法 

​	DHE 算法由于计算性能不佳，因为需要做⼤ᰁ的乘法，为了提升 DHE 算法的性能，所以就出现了现在⼴泛⽤于密 钥交换算法 —— ECDHE 算法。ECDHE 算法是在 DHE 算法的基础上利⽤了 ECC 椭圆曲线特性，可以⽤更少的计算计算出公钥，以及最终的会话密钥。



#### 如何改进HTTP1.1

1. 通过缓存避免发送HTTP请求
2. 减少请求次数
   - 减少重定向请求次数， 将重定向交由代理服务器完成
   - 合并请求，可以减少发的http头部，减少tcp握手和慢启动过程耗费的时间。
   - 延迟发送请求
3. 减少 HTTP响应数据的大小，无损压缩，有损压缩