计算机网络笔记

## 五层参考模型

⽹络协议通常是由上到下，分成 5 层没，分别是应⽤层，传输层，⽹络层，数据链路层和物理层。

### 传输层协议

TCP 的全称叫传输层控制协议（Transmission Control Protocol），⼤部分应⽤使⽤的正是 TCP 传输层协议，⽐ 如 HTTP 应⽤层协议。TCP 相⽐ UDP 多了很多特性，⽐如流量控制、超时重传、拥塞控制等，这些都是为了保证数据包能可靠地传输给对⽅。

 UDP 就相对很简单，简单到只负责发送数据包，不保证数据包是否能抵达对⽅，但它实时性相对更好，传输效率也⾼。当然，UDP 也可以实现可靠传输，把 TCP 的特性在应⽤层上实现。

### 网络层协议

⽹络层最常使⽤的是 IP 协议（Internet Protocol），IP 协议会将传输层的报⽂作为数据部分，再加上 IP 包头组装 成 IP 报⽂，如果 IP 报⽂⼤⼩超过 MTU（以太⽹中⼀般为 1500 字节）就会再次进⾏分⽚，得到⼀个即将发送到⽹ 络的IP 报⽂。

![image-20220409223223860](D:\project\笔记\计算机网络\pic\image-20220409223223860.png)

为了识别不同的设备，⽹络层需要有区分设备的编号。 我们⼀般⽤ IP 地址给设备进⾏编号，对于 IPv4 协议， IP 地址共 32 位，分成了四段，每段是 8 位。

IP 地址可分为两部分： 

- ⽹络号，负责标识该 IP 地址是属于哪个⼦⽹的 
- 主机号，负责标识同⼀⼦⽹下的不同主机

### 数据链路层

为⽹络层提供链路级别传输的服务。

每⼀台设备的⽹卡都会有⼀个 MAC 地址，它就是⽤来唯⼀标识设备的。路由器计算出了下⼀个⽬的地 IP 地址，再通过 ARP 协议找到该⽬的地的 MAC 地址，这样就知道这个 IP 地址是哪个设备的了。

### 物理层 

当数据准备要从设备发送到⽹络时，需要把数据包转换成电信号，让其可以在物理介质中传输，这⼀层就是物理层 （Physical Layer），物理层主要定义了网络中的电气特性。

## HTTP

HTTP 是超⽂本传输协议，也就是HyperText Transfer Protocol。

### 状态码

![image-20220409224307494](D:\project\笔记\计算机网络\pic\http状态码.png)

```
301 永久重定向， 302临时重定向 304 Not Modified 

400 Bad Request 笼统来说请求报文有误 
403 forbidden 服务器禁止访问 
404 not found 找不到资源

500 Internal Server Error 笼统表示服务器内部处理错误 
501 Not implemented 功能尚不支持 
502 Bad GateWay 服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，后端服务器错误 
503 Service Unavaliable 服务器忙
```

### 常见字段

```
Host 指定服务器域名

Content-Length 字段 ：服务器在返回数据时，会有 Content-Length 字段，表明本次回应的数据⻓度。

Connection 字段最常⽤于客户端要求服务器使⽤ TCP 持久连接，以便其他请求复⽤。HTTP/1.1 版本的默认连接都是持久连接，但为了兼容⽼版本的 HTTP，需要指定 Connection ⾸部字段的值为 Keep-Alive。

Content-Type ：字段⽤于服务器回应时，告诉客户端，本次数据是什么格式。

Content-Encoding ：字段说明数据的压缩⽅法。表示服务器返回的数据使⽤了什么压缩格式。
```

### GET 与 POST

Get ⽅法的含义是请求从服务器获取资源，这个资源可以是静态的⽂本、⻚⾯、图⽚视频等。

POST ⽅法则向 URI 指定的资源提交数据，数据就放在报⽂的 body ⾥。

### 优点

「简单、灵活和易于扩展、应⽤⼴泛和跨平台」。

1. 简单 

   HTTP 基本的报⽂格式就是 header + body ，头部信息也是 key-value 简单⽂本的形式，易于理解，降低了学 习和使⽤的⻔槛。

2. 灵活和易于扩展

   HTTP协议⾥的各类请求⽅法、URI/URL、状态码、头字段等每个组成要求都没有被固定死，都允许开发⼈员⾃定义和扩充。 同时 HTTP 由于是⼯作在应⽤层（ OSI 第七层），则它下层可以随意变化。 HTTPS 也就是在 HTTP 与 TCP 层之间增加了 SSL/TLS 安全传输层，HTTP/3 甚⾄把 TCP 层换成了基于 UDP 的 QUIC。

### 缺点

1. 无状态

   ⽆状态的好处，因为服务器不会去记忆 HTTP 的状态，能减轻服务器的负担，把更多的 CPU 和内存⽤来提供服务。⽆状态的坏处，既然服务器没有记忆能⼒，它在完成有关联性的操作时会⾮常麻烦。

2. 明文传输

3. 不安全

   - 通信使⽤明⽂（不加密），内容可能会被窃听。
   - 不验证通信⽅的身份，因此有可能遭遇伪装。
   - ⽆法证明报⽂的完整性，所以有可能已遭篡改。

### 改进

#### HTTP/1.1    HTTP/2     HTTP/3

![image-20220418121004397](D:\project\笔记\计算机网络\pic\HTTP123.png)

##### HTTP1.1

###### 改进

-  使⽤ TCP ⻓连接的⽅式改善了 HTTP/1.0 短连接造成的性能开销。 
- ⽀持管道（pipeline）⽹络传输，只要第⼀个请求发出去了，不必等其回来，就可以发第⼆个请求出去，可以 减少整体的响应时间。

###### 不足

- 请求 / 响应头部（Header）未经压缩就发送，⾸部信息越多延迟越⼤，只能压缩 Body 的部分； 
- 发送冗⻓的⾸部，每次互相发送相同的⾸部造成的浪费较多； 
- 队头阻塞，服务器是按请求的顺序响应的，如果服务器响应慢，会招致客户端⼀直请求不到数据；
-  没有请求优先级控制； 
- 不⽀持服务器推送消息，因此当客户端需要获取通知时，只能通过定时器不断地拉取消息，这⽆疑浪费⼤ᰁ了 带宽和服务器资源。

##### 如何改进HTTP1.1

1. 通过缓存避免发送HTTP请求
2. 减少请求次数
   - 减少重定向请求次数， 将重定向交由代理服务器完成
   - 合并请求，可以减少发的http头部，减少tcp握手和慢启动过程耗费的时间。
   - 延迟发送请求
3. 减少 HTTP响应数据的大小，无损压缩，有损压缩

##### HTTP2

###### 改进

```
1. 头部压缩
2. 二进制格式
3. 数据流
4. 多路复用
5. 服务器推送
```



1. 头部压缩

   HTTP/2 会压缩头（Header）如果你同时发出多个请求，他们的头是⼀样的或是相似的，那么，协议会帮你消除重复的部分。 这就是所谓的 HPACK 算法：在客户端和服务器同时维护⼀张头信息表，所有字段都会存⼊这个表，⽣成⼀个索引号，以后就不发送同样字段了，只发送索引号，这样就提⾼速度了。

   HPACK：

   - 静态字典，包含头部经常出现的字符串。

   - 动态字典，不在静态表中的字符串

   - Huffman 编码（压缩算法）； 

     客户端和服务器两端都会建⽴和维护「字典」，⽤⻓度较⼩的索引号表示重复的字符串，再⽤Huffman 编码压缩数据，可达到 50%~90% 的⾼压缩率。

2. ⼆进制格式

   HTTP/2 不再像 HTTP/1.1 ⾥的纯⽂本形式的报⽂，⽽是全⾯采⽤了⼆进制格式，头信息和数据体都是⼆进制，并且统称为帧（frame）：头信息帧和数据帧，增加了数据传输的效率。

   ![image-20220420161216950](D:\project\笔记\计算机网络\pic\HTTP2frame.png)

3. 数据流

   ​	HTTP/2 的数据包不是按顺序发送的，同⼀个连接⾥⾯连续的数据包，可能属于不同的回应。因此，必须要对数据包做标记，指出它属于哪个回应。 每个请求或回应的所有数据包，称为⼀个数据流（ Stream ）。每个数据流都标记着⼀个独⼀⽆⼆的编号，其中规定客户端发出的数据流编号为奇数，服务器发出的数据流编号为偶数客户端还可以指定数据流的优先级。优先级⾼的请求，服务器就先响应该请求。

4. 多路复用

   HTTP/2 是可以在⼀个连接中并发多个请求或回应，⽽不⽤按照顺序⼀⼀对应。 移除了 HTTP/1.1 中的串⾏请求，不需要排队等待，也就不会再出现「队头阻塞」问题，降低了延迟，⼤幅度提⾼了连接的利⽤率。 

5. 服务器推送

   HTTP/2 还在⼀定程度上改善了传统的「请求 - 应答」⼯作模式，服务不再是被动地响应，也可以主动向客户端发 送消息。 举例来说，在浏览器刚请求 HTML 的时候，就提前把可能会⽤到的 JS、CSS ⽂件等静态资源主动发给客户端，减少延时的等待，也就是服务器推送（Server Push，也叫 Cache Push）。

###### 不足

 	1. 多个 HTTP 请求在复⽤⼀个 TCP 连接，下层的 TCP 协议是不知道有多少个 HTTP 请求 的。所以⼀旦发⽣了丢包现象，就会触发 TCP 的重传机制，这样在⼀个 TCP 连接中的所有的 HTTP 请求都必须等待这个丢了的包被重传回来。
 	2. TCP 与 TLS 的握⼿时延迟
 	3. ⽹络迁移需要重新连接

##### HTTP3

###### 改进

将传输层协议改为UDP，使用QUIC（Quick UDP Internet Connection）协议保证传输的可靠性的。

优点：

- 当某个流发⽣丢包时，只会阻塞这个流，其他流不会受到影响。 

- TLS3 升级成了最新的 1.3 版本，头部压缩算法也升级成了 QPack 。

- 因为 QUIC 内部包含 TLS1.3，因此仅需 1 个 RTT 就可以「同时」完成建⽴连接与 TLS 密钥 协商，甚⾄在第⼆次连接的时候，应⽤数据包可以和 QUIC 握⼿信息（连接信息 + TLS 信息）⼀起发送，达到 0-RTT 的效果。

  ```
  通过连接 ID来标记通信的两个端点，客户端和服务器可以各⾃选择⼀组 ID 来标记⾃⼰，因此即使移动设备的⽹络变化后，导致 IP 地址变化了，只要仍保有上下⽂信息（⽐如连接 ID、TLS 密钥等），就可以“⽆缝”地复⽤原连接，消除᯿连的成本，没有丝毫卡顿感，达到了连接迁移的功能。
  QUIC内部包含了 TLS，它在⾃⼰的帧会携带 TLS ⾥的“记录”，再加上 QUIC 使⽤的是 TLS1.3，因此仅需 1 个 RTT 就可以「同时」完成建⽴连接与密钥协商，甚⾄在第⼆次连接的时候，应⽤数据包可以和 QUIC 握⼿信息（连接信息 + TLS 信息）⼀起发送，达到 0-RTT 的效果。
  ```

  

![image-20220423102650434](D:\project\笔记\计算机网络\pic\http123数据传输.png)

#### HTTPS 

- HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP ⽹络层之间加⼊了 SSL/TLS（Secure Sockets Layer/Transport Layer Security） 安全协议，使得报⽂能够加密传输。
- HTTP 连接建⽴相对简单， TCP 三次握⼿之后便可进⾏ HTTP 的报⽂传输。⽽ HTTPS 在 TCP 三次握⼿之 后，还需进⾏ SSL/TLS 的握⼿过程，才可进⼊加密报⽂传输。
- HTTP 的端⼝号是 80，HTTPS 的端⼝号是 443。
-  HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。



HTTPS解决了HTTP协议的 

1. 窃听风险，加密算法
2. 篡改风险，通过 摘要算法
3. 冒充风险，通过 数字证书

**摘要算法**

摘要算法⽤来实现完整性，能够为数据⽣成独⼀⽆⼆的「指纹」，⽤于校验数据的完整性，解决了篡改的⻛险。

**数字证书**

通过第三方权威机构保证服务器公钥的可信度。

![image-20220418110849612](D:\project\笔记\计算机网络\pic\ca数字证书.png)

HTTPS 是如何建⽴连接的？其间交互了什么？

SSL/TLS 协议基本流程： （这之前要先建立TCP连接）混合加密方式

- 客户端向服务器索要并验证服务器的公钥。 
- 双⽅协商⽣产「会话秘钥」。 
- 双⽅采⽤「会话秘钥」进⾏加密通信。

![img](D:\project\笔记\计算机网络\pic\SSL握手流程图.png)

四次握手 第一次RTT约定加密方式， 第二次RTT验证加密效果。

##### D-H算法

RSA算法的缺点

RSA 没有向前安全性，也就是需要每次的对称加密密钥的传递都是基于公钥加密，服务端私钥解密。如果服务端的私钥丢失了，那几年前的通信数据都有可能被解密。

DH算法中，私钥是随机数，公钥根据随机数生成，所以可以不断更换，满足前向安全。

```java
	双方的任何一方可以生成公共参数p和g，这两个数是公开的，被截获了也没有任何关系，一般情况下由通信双方的服务器端计算。p是一个很大的质数，建议长度在1024比特以上，这个长度也决定了DH算法的安全程度，g表示为一个生成器，这个值很小，可以是2或者5。通过参数，服务器端和客户端会生各自生成一个DH密钥对，私钥需要保密。
	客户端根据公开参数生成一个随机数a，这个随机数是私钥，只有客户端知道，且不会进行发送，然后计算A = (g ^ a) mod p, A就是公钥，需要发送给服务器端。
	服务器端根据公开参数生成一个随机数b，这个随机数是私钥，需要服务器端保密，然后计算B = (g ^ b) mod p, B是公钥，需要发送给客户端。
	客户端发送A数值给服务器端，服务器端计算K = (A ^ b) mod p。
	服务器端发送B数值给发送方，客户端计算K = (B ^ a) mod p。
	服务器端和客户端生成的Z就是会话密钥，协商完成。
```

##### ECDHE握手解析

DHE 算法

​	双⽅的私钥在每次密钥交换通信时，都是随机⽣成的、临时的，这个⽅式也就是 DHE 算法，E 全称是 ephemeral（临时性的）。 所以，即使有个⽜逼的⿊客破解了某⼀次通信过程的私钥，其他通信过程的私钥仍然是安全的，因为每个通信过程 的私钥都是没有任何关系的，都是独⽴的，这样就保证了「前向安全」。

ECDHE 算法 

​	DHE 算法由于计算性能不佳，因为需要做⼤量的乘法，为了提升 DHE 算法的性能，所以就出现了现在⼴泛⽤于密钥交换算法 —— ECDHE 算法。ECDHE 算法是在 DHE 算法的基础上利⽤了 ECC 椭圆曲线特性，可以⽤更少的计算计算出公钥，以及最终的会话密钥。

![image-20220419152457566](C:\Users\85065\AppData\Roaming\Typora\typora-user-images\image-20220419152457566.png)

##### ECDHE算法握手过程

第一次握手：Client Hello ：TLS Version, Cipher Suites, Client Random

第二次握手：

- Sever Hello: 服务端确认的 TLS Version,  从客户端支持的套件中选择一个,  Server Random
- certificate 认证消息
- Server Key Exchange 将DH公钥交给客户端, 服务端会发送曲线、设置基点并保存私钥。（RSA协商不需要这一步，因为整数中的公钥可以用来加密）
- Server Hello Done

第三次握手：

- Client Key Exchange 根据曲线和基点，生成保存私钥并发送公钥，并计算会话密钥。
- Change Cipher Spec 开始使用对称加密算法
- Encrypted Handshake Message 把之前的数据利用摘要算法，加密后发出，用于验证本次生成的密钥是否正常

第四次握手：

- Change Cipher Spec 
- Encrypted Handshake Message

套件一般包括：协商所用算法 + 签名所用算法（一般是RSA） + 通信所用算法（一般是对此算法）+ 摘要算法

##### 总结

RSA 和 ECDHE 握⼿过程的区别：

- RSA 密钥协商算法「不⽀持」前向保密，ECDHE 密钥协商算法「⽀持」前向保密； 
- 使⽤了 RSA 密钥协商算法，TLS 完成四次握⼿后，才能进⾏应⽤数据传输，⽽对于 ECDHE 算法，客户端可以不⽤等服务端的最后⼀次 TLS 握⼿，就可以提前发出加密的 HTTP 数据，节省了⼀个RTT； 
- 使⽤ ECDHE， 在 TLS 第 2 次握⼿中，会出现服务器端发出的「Server Key Exchange」消息，⽽ RSA 握⼿ 过程没有该消息；

#### 如何改进HTTPS2

##### 会话复用

一个RTT即可回复会话。

##### Session ID

![image-20220419154716708](D:\project\笔记\计算机网络\pic\SessionID.png)

#####  Session Ticket

![image-20220419154736709](D:\project\笔记\计算机网络\pic\Seesion Ticket.png)

Session ID 和 Session Ticket 都不具有前向安全性，应对重放攻击比较困难（可以设置过期时间）。

##### 改进握手过程

![image-20220419153206274](D:\project\笔记\计算机网络\pic\改进TLS1.2.png)

 TLS 1.3 把 Hello 和公钥交换这两个消息合并成了⼀个消息， 于是这样就减少到只需 1 RTT 就能完成 TLS 握⼿。

客户端在 Client Hello 消息⾥带上了⽀持的椭圆曲线，以及这些椭圆曲线对应的公钥。 服务端收到后，选定⼀个椭圆曲线等参数，然后返回消息时，带上服务端这边的公钥。经过这 1 个 RTT，双⽅⼿上已经有⽣成会话密钥的材料了，于是客户端计算出会话密钥，就可以进⾏应⽤数据的加密传输了。

1. TSL3废除了RSA和DH算法，仅支持ECDHE。

2. 对于加密和签名算法，只支持目前最安全的几个密码套件，避免了降级攻击。

3. 优化证书的传输和验证，选择更短的椭圆曲线证书，使用OCSP避免查询CRL的消耗。

4. Pre-shared Key，与Session Ticket类似，但同时发送请求和Ticket，同样会遭到重放攻击。

   

![image-20220419154100763](D:\project\笔记\计算机网络\pic\OCSP.png)

OCSP 名为在线证书状态协议（Online Certificate Status Protocol）来查询证书的有效性，它的⼯作⽅式是向 CA 发送查询请求，让 CA 返回证书的有效状态。为了加速对CA的访问出现了OCSP Stapling，向 CA 周期性地查询证书状态，获得⼀个带有时间戳和签名的响应结果并缓存它。



## TCP

### 常见问题

![image-20220423104127562](D:\project\笔记\计算机网络\pic\tcp头部格式.png)

```
- 序列号：在建⽴连接时由计算机⽣成的随机数作为其初始值，通过 SYN 包传给接收端主机，每发送⼀次数据，就
「累加」⼀次该「数据字节数」的⼤⼩。⽤来解决⽹络包乱序问题。
- 确认应答号：指下⼀次「期望」收到的数据的序列号，发送端收到这个确认应答以后可以认为在这个序号以前的数
据都已经被正常接收。⽤来解决不丢包的问题。
- 控制位：
	ACK：该位为 1 时，「确认应答」的字段变为有效，TCP 规定除了最初建⽴连接时的 SYN 包之外该位必须
	设置为 1 。
	RST（ReSet）：该位为 1 时，表示 TCP 连接中出现异常必须强制断开连接。
	SYN：该位为 1 时，表示希望建⽴连接，并在其「序列号」的字段进⾏序列号初始值的设定。
	FIN：该位为 1 时，表示今后不会再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双⽅的主
	机之间就可以相互交换 FIN 位为 1 的 TCP 段。
```

#### TCP协议的作用

IP 层是「不可靠」的，它不保证⽹络包的交付、不保证⽹络包的按序交付、也不保证⽹络包中的数据的完整性。如果需要保障⽹络数据包的可靠性，那么就需要由上层（传输层）的 TCP 协议来负责。 因为 TCP 是⼀个⼯作在传输层的可靠数据传输的服务，它能确保接收端接收的⽹络包是⽆损坏、⽆间隔、⾮冗余和按序的。

#### 什么是TCP

TCP 是⾯向连接的、可靠的、基于字节流的传输层通信协议

1. 面向连接：一对一
2. 可靠：不会因为链路情况编号而丢失报文
3. 字节流：消息是“没有边界”的，且是有序地以字节组成地报文地形式传输。

#### 什么是TCP连接

⽤于保证可靠性和流量控制维护的某些状态信息组合，如**Socket**、**序列号**和**窗⼝大小**称为连接。

#### 如何确定一个TCP连接

源地址、源端口号、目标地址、目标端口号。

#### 理论上的TCP最大连接数

![image-20220423112009408](D:\project\笔记\计算机网络\pic\TCP最大连接数.png)

对 IPv4，客户端的 IP 数最多为 2 的 32 次⽅，客户端的端⼝数最多为 2 的 16 次⽅，也就是服务端单机最⼤ TCP 连接数，约为 2 的 48 次⽅。当然，服务端最⼤并发 TCP 连接数远不能达到理论上限。⾸先主要是⽂件描述符限制，Socket 都是⽂件，所以⾸先要通过 ulimit 配置⽂件描述符的数⽬；另⼀个是内存限制，每个 TCP 连接都要占⽤⼀定内存，操作系统的内存是有限的


- **⽂件描述符**：Socket 实际上是⼀个⽂件，也就会对应⼀个⽂件描述符。在 Linux 下，单个进程打开的⽂件描述符数是有限制的，没有经过修改的值⼀般都是 1024，不过我们可以通过 ulimit （user limit）增⼤⽂件描述符的数⽬；

#### TCP与UDP的区别

UDP 利⽤ IP 提供⾯向「⽆连接」的通信服务，头部只有 8 个字节（ 64 位），UDP 的头部格式如下：

![image-20220423112658335](D:\project\笔记\计算机网络\pic\UDP数据格式.png)

- ⽬标和源端⼝：主要是告诉 UDP 协议应该把报⽂发给哪个进程。 
- 包⻓度：该字段保存了 UDP ⾸部的⻓度跟数据的⻓度之和。
-  校验和：校验和是为了提供可靠的 UDP ⾸部和数据⽽设计。

|                    | TCP                                                          | UDP                                                          |
| ------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 连接               | 面向连接，传输数据前先要创建连接                             | 无需连接，立即传输数据                                       |
| 服务对象           | 一对一                                                       | 一对一、一对多、多对多                                       |
| 可靠性             | 可靠数据交付，数据可以无差错、不丢失、不重复、按序到达       | 尽最大努力交付                                               |
| 拥塞控制、流量控制 | 有                                                           | 没有（发送效率不受网络情况影响）                             |
| 首部开销           | 没有使用选项字段20字节，使用选项会变长                       | 固定8字节，开销小                                            |
| 传输方式           | 流式传输，没有边界，但保证顺序和可靠性                       | 逐包发送，有边界，但可能会丢包和乱序                         |
| 分片不同           | 大于MSS（Maximum Segment Size），会在IP层分片，丢失重传分片。 | 大于MTU会被分片，若要实现可靠传输，丢失重传所有数据包，所以UDP报文应小于MTU |

#### TCP和UDP的应用场景

TCP面向连接，能保障可靠交付因此被用于：

- FTP 文件传输
- HTTPS / HTTPS

UDP面向无连接，开销小，即时发送：

- 包总量较小的通信，如DNS（Domain Name System）、SNMP（Simple Network Management Protocol）等
- 视频、音频等多媒体通信
- 广播通信

#### 为什么 UDP 头部没有「⾸部⻓度」字段，⽽ TCP 头部有「⾸部⻓度」字段呢？ 

 TCP 有可变⻓的「选项」字段，⽽ UDP 头部⻓度则是不会变化的，⽆需多⼀个字段去记录 UDP 的⾸部⻓ 度。

#### TCP 是如何计算负载数据⻓度

```
TCP数据长度 = IP总长度 - IP首部长度 - TCP首部长度
```

### TCP 连接建⽴

![image-20220423120028928](D:\project\笔记\计算机网络\pic\TCP三次握手.png)

（图片有误，SYN_SENT）

#### 三次握手的原理的必要性

1. 避免历史连接（主要原因）：

   如果是历史连接（序列号过期或超时），则第三次握⼿发送的报⽂是 RST 报⽂，以此中⽌历史连接； 如果不是历史连接，则第三次发送的报⽂是 ACK 报⽂，通信双⽅就会成功建⽴连接；

2. 避免资源浪费

3. 同步化序列号

⽽两次握⼿只保证了⼀⽅的初始序列号能被对⽅成功接收，没办法保证双⽅的初始序列号都能被确认接收，同步序列号的意义：

- 接收⽅可以去除重复的数据； 
- 接收⽅可以根据数据包的序列号按序接收； 
- 可以标识发送出去的数据包中， 哪些是已经被对⽅收到的；

#### 为什么初始化序列号是随机的

避免和仍可能存在于网络中的历史报文重复而产生错误。

#### 初始序列ISN是如何产生的

RFC1948中提出了一个较好的初始化序列号ISN随机生成算法。

ISN = M + F(M是一个每4ms 加1的计时器，4.55个小时循环一次， F是根据源、目标IP和端口号使用哈希算法生成的一个随机数值)

#### 既然 IP 层会分⽚，为什么 TCP 层还需要 MSS 呢

![image-20220423194828374](D:\project\笔记\计算机网络\pic\MSS.png)

- MTU ：⼀个⽹络包的最⼤⻓度，以太⽹中⼀般为 1500 字节； 
- MSS ：除去 IP 和 TCP 头部之后，⼀个⽹络包所能容纳的 TCP 数据的最⼤⻓度；

若在IP层分片，因为IP层没有超时重传机制，若有数据丢失，服务端不会响应ACK，发送方超时后需要重传所有信息。

在TCP层进行分段可以只重传该段，所以简历连接时，通常会在前两次握手时协商MSS。

#### 什么是SYN攻击？如何避免SYN攻击

SYN攻击，攻击者伪造大量握手消息，占满服务器的SYN接受队列（未连接队列），使服务不能为正常用户服务。

防御：

1. 修改Linux内核参数，控制队列大小和对面处理策略。
2. SYN cookie, 在未连接队列满后，返回SYN cookie给客户端，之后直接验证客户端的ACK信息，这样就不需要未连接队列来储存报文信息。

### TCP连接断开

![image-20220423202113850](D:\project\笔记\计算机网络\pic\四次挥手.png)

MSL 是 Maximum Segment Lifetime，报⽂最⼤⽣存时间，它是任何报⽂在⽹络上存在的最⻓时间，超过这个时间报⽂将被丢弃。因为 TCP 报⽂基于是 IP 协议的，⽽ IP 头中有⼀个 TTL 字段，是 IP 数据报可以经过的最⼤路 由数，每经过⼀个处理他的路由器此值就减 1，当此值为 0 则数据报将被丢弃，同时发送 ICMP 报⽂通知源主机。 MSL 与 TTL 的区别： MSL 的单位是时间，⽽ TTL 是经过路由跳数。所以 MSL 应该要⼤于等于 TTL 消耗为 0 的 时间，以确保报⽂已被⾃然消亡。

#### 为什么挥手要四次

TCP连接是一个全双工的连接，客户端发出关闭请求，只是不在发送数据，但仍然可以接受数据。

服务器接收到FIN报文时，仍可能有工作需要处理，应先回复ACK报文，然后准备好断开连接后发送FIN报文，

接受到客户端ACK报文后才正式关闭。

#### 为什么TIME_WAIT要等待2MSL的时间

MSL指单项的最大生存时间，2MSL内没有信息可以保证不在有报文发送过来

第一个MSL是为了等自己发出去的最后一个ACK从网络中消失

第二MSL是为了等在对端收到ACK之前的一刹那可能重传的FIN报文从网络中消失。

TIME_WAIT状态保持2MSL的时间可以保证：

1. 连接被服用后，相同四元组的连接不会收到旧的数据包。

2. 保证被动关闭连接的一方可以收到ACK报文而正确关闭。

   如果不能正确关闭，不仅会浪费服务器资源，还可能导致新的连接被拒绝。

#### TIME_WAIT连接时间太长有什么危害？

1. 内存资源占用
2. 对端口的占用，可能导致无法创建新的连接。

### Socket 编程

![image-20220423212025562](D:\project\笔记\计算机网络\pic\socket建立.png)

![image-20220423212100546](D:\project\笔记\计算机网络\pic\socket关闭.png)

### TCP机制

#### 重传机制

##### 超时重传

发送数据后设置定时器，超过指定时间没有收到 ACK 确认应答报文，就重发数据。

触发情况：

1. 数据包丢失
2. 确认应答丢失

超时重传时间（Retransmission Timeout 超时重传时间）：应略大于RTT，多了性能差，少了增加网络拥塞。

![image-20220507163216425](D:\project\笔记\计算机网络\pic\RTO计算.png)

##### 快速重传

触发情况：三次收到相同序号的 ACK。 

##### 快速重传方法

###### SACK

(Selective Acknowledgment) 选择性确认

接收方将数据接受情况发送给发送方，发送方只需要重传丢失的数据。

###### D-SACK（Duplicate SACK）

使用SACK通知发送方哪些数据被重复接受了。

D-SACK 的优点： 

1. 可以让「发送⽅」知道，是发出去的包丢了，还是接收⽅回应的 ACK 包丢了，或者发出的包被延迟了。

   （发出包丢失，重发不会有D-SACK消息。后两者会有）

2. 判断RTO是不是设置的过小了（

   （频繁收到D-SACK消息）

3. 可以知道⽹络中是不是把「发送⽅」的数据包给复制了;

   （如果明明没有重传该数据包，但是收到该数据包的D-SACK）

如何判断 D-SACK:

1. 如果SACK的第一个段的范围被ACK所覆盖

   （发送 SACK 响应，通常见于中间有数据缺失的情况，所以当 ACK 包含 SACK 段时，证明是重复发送。）

2. 如果SACK的第一个段的范围被SACK的第二个段覆盖，那么就是D-SACK

   （SACK 已经记录收到的段中，也有重复的可能。）

[D-SACK](https://blog.csdn.net/u014023993/article/details/85041321)

#### 滑动窗口

窗⼝⼤⼩就是指⽆需等待确认应答，⽽可以继续发送数据的最⼤值。

TCP 头⾥有⼀个字段叫 Window ，也就是窗⼝⼤⼩。 这个字段是接收端告诉发送端⾃⼰还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能⼒来 发送数据，⽽不会导致接收端处理不过来。

![image-20220507201047072](D:\project\笔记\计算机网络\pic\发送窗口.jpg)

TCP 滑动窗⼝⽅案使⽤三个指针来跟踪在四个传输类别中的每⼀个类别中的字节。其中两个指针是绝对指针（指特 定的序列号），⼀个是相对指针（需要做偏移）。

![image-20220507201251194](D:\project\笔记\计算机网络\pic\TCP滑动窗口指针.png)

`可用窗口大小 = SND.WND - (SND.NXT - SND.UNA)`

接收窗口

![image-20220507202237364](D:\project\笔记\计算机网络\pic\接收窗口.png)

> 接收窗⼝和发送窗⼝的⼤⼩是相等的吗？ 

​	并不是完全相等，接收窗⼝的⼤⼩是约等于发送窗⼝的⼤⼩的。 因为滑动窗⼝并不是⼀成不变的。⽐如，当接收⽅的应⽤进程读取数据的速度⾮常快的话，这样的话接收窗⼝可以 很快的就空缺出来。那么新的接收窗⼝⼤⼩，是通过 TCP 报⽂中的 Windows 字段来告诉发送⽅。那么这个传输过 程是存在时延的，所以接收窗⼝和发送窗⼝是约等于的关系。

#### 流量控制

目的：避免发送超过接收方处理能力的数据。

TCP规定不允许先减少缓存，又收缩窗口，否则会产生丢包现象。

##### 窗口关闭

如果窗⼝⼤⼩为 0 时，就会阻⽌发送⽅给接收⽅传递数据，直到窗⼝变为⾮ 0 为⽌，这就是窗⼝关闭。

> TCP 是如何解决窗⼝关闭时，潜在的死锁现象呢？

​	潜在死锁现象：窗口关闭后，重启窗口的数据丢失。导致窗口一直未开启。

​	为了解决这个问题，TCP 为每个连接设有⼀个持续定时器，只要 TCP 连接⼀⽅收到对⽅的零窗⼝通知，就启动持 续计时器。 如果持续计时器超时，就会发送窗⼝探测 ( Window probe ) 报⽂，⽽对⽅在确认这个探测报⽂时，给出⾃⼰现在的接收窗⼝⼤⼩。

​	窗⼝探测的次数⼀般为 3 次，每次⼤约 30-60 秒（不同的实现可能会不⼀样）。如果 3 次过后接收窗⼝还是 0 的 话，有的 TCP 实现就会发 RST 报⽂来中断连接。

##### 糊涂窗口综合征

由于接收方不能及时处理缓存数据，导致接收窗口变小，使得发送方发动的数据中，报头消耗占很大部分的情况。

解决方式：

1. 接收方：接收方窗口大小 `< min(MSS, 缓存空间/2)`，会通告窗口为零，阻止发送方继续发送，直到该条件不满足。
2. 发送方：Nagle 算法，等到以下两种情况才回复信息。
   1. `窗口大小 >= MSS` 并且`数据大小 >= MSS`
   2. 收到之前发送数据的 ACK 回包。

#### 拥塞控制

目的：避免发送超过网络处理能力的数据。

CWND(congestion window)

##### 慢启动门限

ssthresh （slow start threshold）。 

当 cwnd < ssthresh 时，使⽤慢启动算法。 当 cwnd >= ssthresh 时，就会使⽤「拥塞避免算法」。

##### 慢启动

当发送⽅每收到⼀个 ACK，**拥塞窗⼝ cwnd 的⼤⼩就会加 1** ，等价于每个轮次（发出的数据包都得到响应，约为1个RTT）增加一倍。

##### 拥塞避免

当发送⽅每收到⼀个 ACK，**cwnd 增加 1/cwnd**，等价于每个轮次增加1。



##### 超时重传

- ssthresh 设为 cwnd/2 

- cwnd 重置为 1

![image-20220507205815294](D:\project\笔记\计算机网络\pic\超时重传.png)

##### 快速重传

- cwnd = cwnd/2 ，也就是设置为原来的⼀半; 
- ssthresh = cwnd ; 
- 进⼊快速恢复算法

快速恢复算法：

拥塞窗⼝ cwnd = ssthresh + 3 （ 3 的意思是确认有 3 个数据包被收到了）；

重传丢失的数据包； 

如果再收到重复的 ACK，那么 cwnd 增加 1；

如果收到新数据的 ACK 后，把 cwnd 设置为 ssthresh 的值，原因是该 ACK 确认了新的数据，说明从 duplicated ACK 时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进⼊拥塞避免状态.

[NewReno](https://coolshell.cn/articles/11609.html#%E5%BF%AB%E9%80%9F%E6%81%A2%E5%A4%8D%E7%AE%97%E6%B3%95_-_Fast_Recovery)

![快速恢复](D:\project\笔记\计算机网络\pic\快速恢复算法.png)

#### Fast Open

客户端在第一次三次握手之后保存cookie，再次连接时，SYN报文中可以携带cookie和数据，是的数据传输可以先于连接建立，之后连接建立，传输过程与非TFO（TCP Fast Open）一致。

## IP

一个网络中，主机号全为1的为广播地址，全为0的代表该网络。

D类网址：224.0.0.0 - 239.255.255.255 IP多播

多播⽤于将包发送给特定组内的所有主机。

A、B、C、D分类判断简单，但没有层次结构，不能很好的与现实网络匹配。

⽆分类地址 CIDR和子网掩码 ： 划分网络号和主机号。

### IP 地址与路由控制

路由器根据最长匹配寻找转发到下一跳。

### IP 分⽚与重组

以太⽹的 MTU 是 1500 字节等。

在分⽚传输中，⼀旦某个分⽚丢失，则会造成整个 IP 数据报作废，所以 TCP 引⼊了 MSS 也就是在 TCP 层进⾏分⽚不由 IP 层分⽚，那么对于 UDP 尽量不要发送⼀个⼤于 MTU 的数据报⽂。

### IPv6

优点

IPv6 可⾃动配置，即使没有 DHCP 服务器也可以实现⾃动分配IP地址，真是便捷到即插即⽤啊。 

IPv6 包头包⾸部⻓度采⽤固定的值 40 字节，去掉了包头校验和，简化了⾸部结构，减轻了路由器负荷，⼤⼤提⾼了传输的性能。

IPv6 有应对伪造 IP 地址的⽹络安全功能以及防⽌线路窃听的功能，⼤⼤提升了安全性。

IPv4 点分十进制，共32位， IPv6 冒号分割每十六位一组，共128位。

如果出现连续的 0 时还可以将这些 0 省略，并⽤两个冒号 「::」隔开。但是，⼀个 IP 地址中只允许出现⼀次两个 连续的冒号。

![image-20220523230422934](D:\project\笔记\计算机网络\pic\IPv4.png)

### IP相关技术

#### DNS域名解析

Domain name server

##### 域名的层级关系 

根 DNS 服务器 => 顶级域 DNS 服务器（com） => 权威 DNS 服务器（server.com）

##### 域名解析流程

查看缓存：

浏览器缓存 => 操作系统缓存 => 本机域名解析文件 => 向DNS服务器查询

查询过程：

本地DNS服务器 => 根域名服务器 => 顶级域名服务器 => 权威域名服务器

#### ARP协议

Address Resolution Protocol

流程

主机广播ARP请求， 这个包中包含了想解析的IP地址

同一链路中的所有设备收到ARP请求时，解析发现目标是自己时，返回ARP相应包给主机

如果所要请求的设备不在一个网段中，ARP请求会发送给网关，由网关广播请求。

#### RARP协议

由Mac地址请求IP地址, 通常需要一台服务器响应请求。

#### DHCP协议

Dynamic Host Configuration Protocol

 步骤：

客户端⾸先发起 DHCP 发现报⽂（DHCP DISCOVER） 的 IP 数据报，由于客户端没有 IP 地址，也不知道 DHCP 服务器的地址，所以使⽤的是 UDP ⼴播通信，其使⽤的⼴播⽬的地址是 255.255.255.255（端⼝ 67） 并且使⽤ 0.0.0.0（端⼝ 68） 作为源 IP 地址。DHCP 客户端将该 IP 数据报传递给链路层，链路层然后将帧⼴ 播到所有的⽹络中设备。

 DHCP 服务器收到 DHCP 发现报⽂时，⽤ DHCP 提供报⽂（DHCP OFFER） 向客户端做出响应。

该报⽂仍然使⽤ IP ⼴播地址 255.255.255.255，该报⽂信息携带服务器提供可租约的 IP 地址、⼦⽹掩码、默认⽹关、 DNS 服务器以及 IP 地址租⽤期。

客户端收到⼀个或多个服务器的 DHCP 提供报⽂后，从中选择⼀个服务器，并向选中的服务器发送 DHCP 请 求报⽂（DHCP REQUEST进⾏响应，回显配置的参数。 最后，服务端⽤ DHCP ACK 报⽂对 DHCP 请求报⽂进⾏响应，应答所要求的参数。

DHCP中继代理

DHCP中继代理以单播的形式与DHCP服务器练习，并以广播的方式回复网段中的客户端。

#### NAT

网络地址转换

（Network Address Port Translation）

将局域网的本地IP映射为NAPT路由器的不同端口。、

缺点：

外部⽆法主动与 NAT 内部服务器建⽴连接。 

转换表的⽣成与转换操作都会产⽣性能开销。

通信过程中，如果 NAT 路由器重启了，所有的 TCP 连接都将被᯿置。

改进方法：

改用IPv6

NAT穿透技术

#### ICMP

Internet Control Message Protocol

封装在IP报文中

主要功能：确认 IP 包是否成功送达⽬标地址、报告发送过程中 IP 包被废弃的原因和改善⽹络设置等。

ICMP ⼤致可以分为两⼤类：

- ⼀类是⽤于诊断的查询消息，也就是「查询报⽂类型」 
- ⼀类是通知出错原因的错误消息，也就是「差错报⽂类型」

![image-20220524211807105](D:\project\笔记\计算机网络\pic\ICMP报文种类.png)

##### Ping

ping 命令基于查询报文实现。

可以向对端主机发送回送请求的消息（ ICMP Echo Request Message），也可以接收对端主机发回来的 回送应答消息（ ICMP Echo Reply Message ）。

##### 差错报文类型

- 目标不可达

  - 网络、主机、协议、端口不可达 或者 需要进行分片但设置了不分片

- 源点抑制

  ​	路由器在网络拥堵时向IP数据报的源地址发送，抑制发送，导致网络通信不公平，很少使用。

- 重定向消息

  告知主机最优的路由信息。

- 超时消息

  TTL（Time To Live）减少到零，导致IP包被丢弃时发送给源主机。

##### traceroute

发送UDP包，**设置不同的TTL**，**追踪到目的地路线上的路由器**。

traceroute 在发送 UDP 包时，会填⼊⼀个不可能的端⼝号值作为 UDP ⽬标端⼝号（⼤于 3000 ）。当⽬的主机，收到 UDP 包后，会返回 ICMP 差错报⽂消息，但这个差错报⽂消息的类型是「端⼝不可达」。 所以，当差错报⽂类型是端⼝不可达时，说明发送⽅发出的 UDP 包到达了⽬的主机。

traceroute 还有⼀个作⽤是**故意设置不分⽚，从⽽确定路径的 MTU**。

#### IGMP

Internet Group Management Protocol

IGMP就是用来在接收者主机和与其所在网段直接相邻的组播路由器之间建立、维护组播组成员关系的协议。

主机报告加入/离开组播组

路由器查询组播组是否还有成员、主机超时等待，超时时间内没有响应则响应查询。

## 常见Q&A

### 键入网址到网页显示，期间发生了什么？

1. 解析URL

​	一般包括： 访问协议 + 访问服务器 + 访问资源

2. 生成HTTP请求

   HTTP报文包括，请求行 （请求方法 + URL + 协议）+ 请求头 + 请求体

3. DNS 域名解析

4. 应用程序调用 Socket 库，委托协议栈。TCP/UDP 以及 IP（包含ICMP 和 ARP）

5. TCP建立连接，可能根据 MSS 对数据进行进行分片，生成报文

6. 网络层中，IP协议将报文封装为网络包发送（封装报文时，如果用于多个网卡，源IP需要路由表来确认）

7. 网络层将信息传输看作是两个主机之间的传输。实际在链路层中，需要MAC地址确认下一跳的目的地。可以通过ARP协议来获得MAC地址。

8. 网卡驱动从IP模块获取到包，将其复制到网卡内的缓存区，主要在收尾附加帧定界符，还会在末尾加上用于检测错误的帧校验序列，最后⽹卡会将包转为电信号，通过⽹线发送出去。

9. 交换机  ⾸先，电信号到达⽹线接⼝，交换机⾥的模块进⾏接收，接下来交换机⾥的模块将电信号转换为数字信号。 然后通过包末尾的 FCS 校验错误，如果没问题则放到缓冲区。交换机根据 MAC 地址表查找 MAC 地址，然后将信号发送到相应的端⼝，否则转发到除源端口外的所有端口。

10. 路由器各个端⼝都具有 MAC 地址和 IP 地址, 路由器会根据路由表对包进行转发。

**到达服务器后**

应用层的HTTP报文会经过传输层，网络层，链路层的层层封装。到达服务器后，服务器会检查数据的正确性，解封数据并向上层传递。

### PUT 与 POST

相对于POST， PUT方法在协议层面实现了幂等性。根据RFC7231，虽然对资源所表示的东西，和资源状态是否一致的判定由服务器自行定义，但这种应该实现幂等的规则在协议层面就被规定了，体现在，例如返回的状态码。
