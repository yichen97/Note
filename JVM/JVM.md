# JVM

## 垃圾收集器与内存分配策略

### 可达性分析算法

**GC Root:**

- 虚拟机栈中引用的对象

- 方法区中类静态属性引用的变量

- 方法区中常量引用的对象

- Java虚拟机内部引用，如基本数据类型对应的Class对象，一些常驻异常对象（如`NullPointException`，`OutOfMemory`）

- 被同步锁持有的对象

  等...

### 并发可达性分析

三色标记：

- 黑色：根节点，或与黑色节点相连，已经被访问，且所有引用均被遍历过的节点。
- 灰色：与黑色节点相连，但至少有一个引用还没有被遍历。
- 白色：对象尚未被垃圾收集器访问。

定理：当且仅当以下两个条件同时成立，会产生被错误标记为白色节点的黑色节点。

- 插入一条或多条黑色到白色节点的依赖 `-> ` CMS 增量标记法，标记被插入引用的黑色节点，再次扫描
- 删除全部灰色到白色的直接或间接依赖 `->` G1 原始快照，标记被删除引用的灰色节点， 再次扫描



### 追踪式垃圾收集

算法：

- 标记-清除：卡顿少，但内存碎片多，导致有很多空余空间却无法分配对象，导致`Full GC`。

- 标志-复制：实现简单高效，没有碎片。解决了标记-清除算法面对大量可回收对象时执行效率低的问题，但要付出等量的额外空间。一般用于Minor GC。`Serial`，`ParNew`等收集器，将新生代分为Eden : Survivor（有两个） = 8 ：1。但是减小用于复制的空间，需要老年代的内存分配担保。此时，Survivor不足以存放存活对象会被移动到老年代。

- 标志-整理：应对大部分对象存活的情况。标记存活对象，向内存一端移动并清除掉边界之外的内存。

  与标志-清除法相比，整理会导致更长时间的停顿，而不整理仅清除会导致分配更加复杂。

### 根节点枚举

可达性分析算法需要枚举根节点作为开始，在枚举根节点的过程中，所有的垃圾收集器都必须暂停用户线程。

根节点的枚举需要在一个能保障一致性的快照中进行 `->` 依赖关系不变

#### 安全点

一般使用主动式中断。

#### 安全区

在用户线程处于Sleep 或者 Blocked 状态，不能实现主动中断，但由于此时引用关系不会变化，引出了安全区的概念。

- 进入安全区才开始GC
- GC完毕才离开安全区

### 记忆集和卡表

解决跨代引用问题，一般使用的精度为卡精度，使用**写后屏障维护**，表示一块内存区域有没有要回收的对象，以避免遍历整个老年代。

修改卡表时，作为多线程的共享变量可能出现伪共享的问题，解决方案是CAS操作，并且标记过就不再标记。

### 垃圾回收器种类

#### 分代理论

内存占用、停顿时间、吞吐量 不可能三角。

| 回收器            | 分代   | 特点                                       | 回收算法       |
| ----------------- | ------ | ------------------------------------------ | -------------- |
| Serial            | Young  | STW，不与用户线程并发 简单高效、内存消耗少 | 标记 - 复制    |
| Serial Old        | Old    | 同上                                       | 标记 - 整理    |
| ParNew            | Young  | STW, 实现并行收集，常搭配CMS使用           | 标记 - 复制    |
| Parallel Scavenge | Young  | 并行收集、有自适应调节策略。吞吐量优先。   | 标记 - 复制    |
| Parallel Old      | Old    | 多线程并行收集                             | 标记 - 整理    |
| CMS               | Old    | 最短停顿时间                               | 标记 - 清除    |
| G1                | Region | 均衡                                       | 标记-整理+复制 |

CMS (Concurrent Mark Sweep) 流程：

初始标记 ： 不并行，不并发

并发标记：不并行，并发

重新标记：并行，不并发

并发清除：不并行，并发

由于并发标记和清理，该过程中产生的浮动垃圾必须留存到下次GC，并且需要预留给用户线程分配内存的空间。

如果并发过程中用户线程无法分配内存，将导致一次STW的 Full GC。

#### 基于Region

##### G1

整体来看，基于标记-整理算法，但从Region之间来看，又是标记-复制算法，再复制过程中

不再面向分代收集，面向内存中划分的Region收集最有价值的Region。

Region需要扮演Eden, Survivor，Old的身份。

使用记忆集解决跨Region引用，内存消耗大。

流程：

- 初始标记
- 并发标记
- 最终标记 ： 并行，不并发
- 筛选回收 ： 并行，不并发，收集最有价值的Region

##### Shenandoah（略，一般不考察）

使用邻接表代替卡表，使用读屏障转发指针保证并发复制存活对象。

使用CAS保证，对存活对象的写操作（写在新创建的副本里）。

##### ZGC（略，一般不考察）

读屏障（实现指针自愈）、染色指针（将额外信息储存到指针上）、内存多重映射（保证染色指针对物理内存的映射）。

### 实战

#### 触发GC

Eden没有足够空间， 触发Minor GC

Survivor空间不足，空间分配担保进入老年代，如失败，触发Full GC.

CMS由于浮动垃圾导致并发失败，触发Full GC



大对象会直接进入老年代

长期存活对象进入老年代

- 存活时间足够长
- 相同年龄的对象啊达到Survivor的一半。



## 类文件结构

虚拟机的无关性特点，平台无关性、语言无关性。

类文件，高位在前。

文件格式，仅包含无符号数和“表”（某种数据结构的数组，以xx__info表示）

| 类型           | 名称                | 数量                  |
| -------------- | ------------------- | --------------------- |
| u4             | magic               | 1                     |
| u2             | minor_version       | 1                     |
| u2             | major_version       | 1                     |
| u2             | constant_pool_count | 1                     |
| cp_info        | constant_pool       | constant_pool_count-1 |
| u2             | access_flag         | 1                     |
| u2             | this_class          | 1                     |
| u2             | super_class         | 1                     |
| u2             | interface_count     | 1                     |
| u2             | interface           | interface_count       |
| u2             | fields_count        | 1                     |
| field_info     | fields              | fields_count          |
| u2             | method_count        | 1                     |
| method_info    | methods             | methods_count         |
| u2             | attributes_count    | 1                     |
| attribute_info | attributes          | attributes_count      |



### 常量池（constant pool）

主要存放：**字面量**（Literal）和**符号引用**（Symbolic Reference）

符号引用主要包括：

- 类或接口的全限定名

- 字段名称和描述符

- 方法名称和描述符

常量池中，每一项常量都是一个表，表结构的起始第一位是个u1类型的标志位，标志了当前常量的类型。

#### CONSTANT_Integer_info型常量

| 项目  | 类型 | 描述                  |
| ----- | ---- | --------------------- |
| tag   | u1   | 值为3                 |
| bytes | u4   | 按照高位在前储存int值 |

#### CONSTANT_Class_info型常量数据结构

| 类型 | 名称       | 数量 |
| ---- | ---------- | ---- |
| u1   | tag        | 1    |
| u2   | name_index | 1    |

name_index是常量池索引，指向常量池中的一个CONSTANT_Utf8_info类型常量，此常量代表了这个类（或者接口）的全限定名.

符号引用都需要引用CONSTANT_Utf8_info型常量。

### 访问标志

两个字节，将bit 0、1 作为布尔值代表是否被声明为某类型。

### 类索引、父索引与接口索引集合

先指向CONSTANT_Class_info再指向对应的CONSTANT_Utf8_info

### 字段表集合

| 类型           | 名称                                | 数量             |
| -------------- | ----------------------------------- | ---------------- |
| u2             | access_flags                        | 1                |
| u2             | nams_index（简单名称引用）          | 1                |
| u2             | descriptor_index （字段描述符引用） | 1                |
| u2             | attribute_count                     | 1                |
| attribute_info | attributes                          | attributes_count |

（字段描述符：byte int 等，对象类型用 “L” + 全限定名表示，数组每有一个维度就加一个 “[”）

字段列表中不会出现父类或者从父类接口中继承而来的字段，但可能出现原本Java代码中不存在的字段。比如内部类中，为了保持对外部类的访问，编译器会自动添加指向外部类实力的字段。

### 方法表集合

| 类型           | 名称                            | 数量             |
| -------------- | ------------------------------- | ---------------- |
| u2             | access_flags                    | 1                |
| u2             | nams_index（简单名称引用）      | 1                |
| u2             | descriptor_index （描述符引用） | 1                |
| u2             | attribute_count                 | 1                |
| attribute_info | attributes                      | attributes_count |

方法体中的代码，经过Javac编译器编译成字节码指令之后，存放在方法属性表集合中一个名为“Code”的属性里面。

**Java语言不支持字段重载，Class对象只要字段描述符不同就合法。**

**Java语言不支持仅返回值不同的重载，Class对象支持，这是由于方法签名的范围不同。**特征签名是指一个方法中个参数在常量池中的字段符号引用集合，也正是因为返回值不会包含在特征签名之中，所以Java语言里面是无法仅仅依靠返回值的不同来对一个以后方法的重载。但在class文件中，特征签名的范围明显要更大一些，所以只要返回值不同也可以合法共存于同一个Class文件中。

### 属性表集合

Class文件，字段表，方法表都可以携带自己的属性表。

## 虚拟机类加载机制

Java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这个过程被称作虚拟机的类加载机制。

用户可以通过Java预置的或自定义的类加载器，让某个本地应用程序在运行时从网络或其他地方加载一个二进制流作为其程序代码的一部分。

**类的生命周期：加载、连接、初始化、使用、卸载。初始化又分为验证、准备和解析。**

**有且只有六种情况对类进行初始化：**

1. new、getstatic、putstatic、invokestatic这四条字节码指令

- 使用new关键字实例化对象
- 读取或设置一个静态字段（被final修饰，编译期已经被放进常量池的除外）
- 调用一个类的静态方法

2. 使用java.lang.reflect 包的方法对类型进行反射调用

3. 初始化类前，应先初始化其父类。

4. 启动虚拟机会先初始化主类（main()）

5. 使用动态语言支持的时候，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果为REF_getStatic, REF_putStatic, REF_invokeStatic, REF_newinvokeSpecial四种类型句柄，并且这个方法句柄对应的类没有初始化。

6. 当一个接口定义了默认方法，当其实现类初始化时，要先初始化该接口

   

除此之外，所有被动的引用都不会触发初始化：

- 引用父类的静态字段
- 引用某类被标记为final的某静态字段
- 初始化一个某类的数组，不会使其初始化

### 类的加载过程

#### 加载

1. 通过一个类的全限定名来获取定义此类的二进制字节流
2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
3. 在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口。

可从ZIP中读取，发展出JAR、WAR格式

从网络读取，如Web Applet

由其他文件生成，如JSP

数组本身不通过类加载器创建，但数组将被表示在加载数组组件的类加载器的类名称空间上。

#### 验证

1. **格式验证**

   - 魔数、次主版本号、常量池数、常量池表、访问标志、该类、父类、接口数、接口表、字段数、字段表、方法数、方法表、属性表

2. **元信息**

   该类是否符合Java语言规范规定

   - 是否有父类
   - 这个类的父类是否继承了不允许继承的类（如final类）
   - 如果不是抽象类，是否实现了其父类或接口中要求实现的所有方法。
   - 类中的字段，方法是否与父类矛盾（比如覆盖final标志的字段）

3. **字节码**

   Class文件的Code属性。

   保证方法运行时不会做出危害虚拟机安全的行为。

   - 操作数和指令代码能配合，不会出现如防止int却以long读出的情况

   - 保证跳转指令不会跳转到方法体外

   - 保证方法中的类型转换有效

     ...

4. **符号引用**

   该类是否缺少或者被禁止访问它以来的某些外部类、方法、字段等资源：

- 符号引用中通过字符串描述的全限定类名是否能找到对应的类

- 被指定类中是否存在符合描述的方法或字段

- 这些方法字段的可访问性

  ...

#### 准备

为类中定义的变量（静态变量，不含非静态变量）分配内存并设置类变量的初始值。

final修饰的字段，会被设置为常量池中生成的ConstantValue。

#### 解析

替换常量池中的符号引用为直接引用。

解析主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点。

1. 类、接口的解析

   如果当前代码所处类为D，一个从未解析过的符号引用N解析为一个类或接口C的直接引用。

   1. 不是数组，直接加载C
   2. 是数组，加载数组中的类，并交由虚拟机生成数组
   2. 验证D对C的访问权限，不通过抛出IllegalAccessError。
   
2. 字段解析

   1. 查找当前类，是否包含简单名称和字段描述符都与目标匹配的字段。
   2. 否则，如果该类实现类接口，按继承关系从下往上搜索各个接口及其父接口
   3. 否则，如果该类不是Object，按继承关系从下往上搜索其父类
   4. 否则，查找失败抛出NoSuckFieldError。如果找到，，不通过抛出IllegalAccessError。

3. 方法解析

   1. 由于Class文件中，类的方法和几口的方法符号引用的常量类型定义是分开的，如果在类的方法表中索引的目标是一个接口的话，抛出IncompatibleClassChangeError
   2. 通过第一步后，在该类中查找是否有简单名称和描述符都匹配的方法
   3. 否则，查找父类
   4. 否则在实现的接口及其父接口中查找，如果匹配说明该类为抽象类，抛出AbstractMethodError
   5. 否则抛出NoSuchMethodError

4. 接口方法解析

   1. 如果索引的对象是个类则直接抛出异常
   2. 否则，在该接口内寻找
   3. 否则，在父接口中寻找
   4. 在父接口中找到多个方法，编译器可能拒绝编译。


### 初始化

根据程序代码，初始化类变量和其他资源。是执行`<client>()`方法的过程。

静态语句块中，只能访问到定义在静态语句块前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但不能访问。

![img](D:\project\笔记\JVM\pic\70)

![img](D:\project\笔记\JVM\pic\1.jpg)

### 类加载器

## 

## 方法调用

### 解析

非虚方法

#### 分派

虚方法

静态分派

动态分派

invokevirtual 根据类的实际类型解析引用。

![img](D:\project\笔记\JVM\pic\webp)
