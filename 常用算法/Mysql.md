# Mysql

## 优化

优化回表

大量数据分页操作

```sql
select * from t limit 900000000, 100;
```

查阅资料发现“limit”的工作方式是：
第一步.先查询offset+count条数据；
第二步.再抛弃前offset条数据
但是全字段查询肯定会有回表查询操作，这就导致了进行百万次的回表查询，速度肯定会很慢，于是我的解决思路是，在“第一步”时不进行回表查询，这样会不会效率提高很多，于是把sql改成下面的等效查询。

 优化为：

```sql
select * from test a right join (select id from t limit 9000000, 100) b on a.id = b.id;
```

## **Mysql复杂查询语句的优化，你会怎么做？**

说到复杂SQL优化，最多的是由于多表关联造成了大量的复杂的SQL语句，那我们拿到这种sql到底该怎么优化呢，实际优化也是有套路的，只要按照套路执行就行。复杂SQL优化方案：

1. 使用EXPLAIN关键词检查SQL。EXPLAIN可以帮你分析你的查询语句或是表结构的性能瓶颈，就得EXPLAIN 的查询结果还会告诉你你的索引主键被如何利用的，你的数据表是如何被搜索和排序的，是否有全表扫描等；
2. 查询的条件尽量使用索引字段，如某一个表有多个条件，就尽量使用复合索引查询，复合索引使用要注意字段的先后顺序。
3. 多表关联尽量用join，减少子查询(因为多了创建和删除临时表的操作)的使用。表的关联字段如果能用主键就用主键，也就是尽可能的使用索引字段。如果关联字段不是索引字段可以根据情况考虑添加索引。
4. 尽量使用limit进行分页批量查询，不要一次全部获取。
5. 绝对避免select *的使用，尽量select具体需要的字段，减少不必要字段的查询；
6. 尽量将or 转换为 union all。
7. 尽量避免使用is null或is not null。
8. 要注意like的使用，前模糊和全模糊不会走索引。
9. Where后的查询字段尽量减少使用函数，因为函数会造成索引失效。
10. 避免使用不等于（!=），因为它不会使用索引。
11. 用exists代替in，not exists代替not in，效率会更好；
12. 避免使用HAVING子句, HAVING 只会在检索出所有记录之后才对结果集进行过滤，这个处理需要排序，总计等操作。如果能通过WHERE子句限制记录的数目,那就能减少这方面的开销。
13. 千万不要 ORDER BY RAND()

## 如何解决幻读

幻读定义：一次事务中两次查询的记过不同。

1. MVCC

​	对于记录的读取发生在一致性快照上，使得其他事物对数据的修改对当前事务不可见，就不会出现幻读问题。

2. 间隙锁

​	对索引和索引间的间隙，使得想要修改当前事务查询数据的事务被阻塞，不会出现幻读问题。