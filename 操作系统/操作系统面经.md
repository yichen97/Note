# 操作系统面经

## 用户态转换到核心态的情况

**核心态和用户态是操作系统两种运行级别。**

核心态就是拥有资源较多的状态，或者说访问资源多的状态，也称之为特权态；相对来说，用户态就是非特权态，访问资源将受到限制。

核心态下CPU可执行任何指令，而用户态下CPU只能执行非特权指令。当CPU处于核心态时可随意进入用户态；而处于用户态时，切换到核心态只有在系统调用和中断时才能发生。一般程序一开始都是运行与用户态，当程序需要系统资源时，就必须通过中断进入核心态。

1）用户态切换到内核态的3种方式

a. 系统调用

这是用户态进程主动要求切换到内核态的一种方式，用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作，比如fork()实际上就是执行了一个创建新进程的系统调用。而系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现，例如Linux的int 80h中断。

b. 异常

当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常。

c. 外围设备的中断

当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。

这3种方式是系统在运行时由用户态转到内核态的最主要方式，其中系统调用可以认为是用户进程主动发起的，异常和外围设备中断则是被动的。

 

核心态和用户态各有优势：运行在核心态的程序可访问的资源多，但可靠性、安全性要求高，维护管理比较复杂。一个程序运行在哪取决于其对资源和效率的需求。

 

**用户栈和内核栈**

内核在创建进程的时候，会为进程创建相对于的堆栈。每个进程有两个栈，一个用户栈，存在于用户空间；一个内核栈，存在于内核空间。当进程运行在用户态时，CPU堆栈指针寄存器里的内容是用户堆栈地址，使用用户栈；在核心态时，同理。

当进程因为中断或系统调用而进入内核态时，进程所使用的堆栈也要有用户栈转到内核栈。进程陷入内核态后，先把用户堆栈的地址保存到内核栈之中，然后设置堆栈指针寄存器的内容为内核栈的地址；当恢复到用户态时，把内核栈中保存的用户栈的地址恢复到堆栈指针寄存器即可。

进程从用户态转到内核态时，进程的内核栈总是空的，所以进程陷入内核的时候，直接把栈顶地址给堆栈指针寄存器即可。