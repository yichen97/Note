# JVM

## 垃圾收集器与内存分配策略

### 可达性分析算法

GC Root:

- 虚拟机栈中引用的对象

- 方法区中类静态属性引用的变量

- 方法区中常量引用的对象

- Java虚拟机内部引用，如基本数据类型对应的Class对象，一些常驻异常对象（如`NullPointException`，`OutOfMemory`）

- 被同步锁持有的对象

  等...

### 并发可达性分析

三色标记：

- 黑色：根节点，或与黑色节点相连，已经被访问，且所有引用均被遍历过的节点。
- 灰色：与黑色节点相连，但至少有一个引用还没有被遍历。
- 白色：对象尚未被垃圾收集器访问。

定理：当且仅当以下两个条件同时成立，会产生被错误标记为白色节点的黑色节点。

- 插入一条或多条黑色到白色节点的依赖 `-> ` CMS 增量标记法，标记被插入引用的黑色节点，再次扫描
- 删除全部灰色到白色的直接或间接依赖 `->` G1 原始快照，标记被删除引用的灰色节点， 再次扫描



### 追踪式垃圾收集

算法：

- 标记-清除：卡顿少，但内存碎片多，导致有很多空余空间却无法分配对象，导致`Full GC`。

- 标志-复制：实现简单高效，没有碎片。解决了标记-清除算法面对大量可回收对象时执行效率低的问题，但要付出等量的额外空间。一般用于Minor GC。`Serial`，`ParNew`等收集器，将新生代分为Eden : Survivor（有两个） = 8 ：1。但是减小用于复制的空间，需要老年代的内存分配担保。此时，Survivor不足以存放存活对象会被移动到老年代。

- 标志-整理：应对大部分对象存活的情况。标记存活对象，向内存一端移动并清除掉边界之外的内存。

  与标志-清除法相比，整理会导致更长时间的停顿，而不整理仅清除会导致分配更加复杂。

### 根节点枚举

可达性分析算法需要枚举根节点作为开始，在枚举根节点的过程中，所有的垃圾收集器都必须暂停用户线程。

根节点的枚举需要在一个能保障一致性的快照中进行 `->` 依赖关系不变

#### 安全点

一般使用主动式终端。

#### 安全区

在用户线程处于Sleep 或者 Blocked 状态，不能实现主动终端，但由于此时引用关系不会变化，引出了安全区的概念。

- 进入安全区才开始GC
- GC完毕才离开安全区

### 记忆集和卡表

解决跨代引用问题，一般使用的精度为卡精度，表示一块内存区域有没有要回收的对象，以避免遍历整个老年代。

修改卡表时，作为多线程的共享变量可能出现伪共享的问题，解决方案是CAS操作，并且标记过就不再标记。

### 垃圾回收器种类

| 回收器 | 分代        | 特点 | 回收算法    |
| ------ | ----------- | ---- | ----------- |
| Serial | Minor/Young |      | 标记 - 复制 |

